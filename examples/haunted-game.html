<html>
  <head>
    <title>haunted-game</title>
    <link rel="stylesheet" href="/styles.css" />
    <script type="module" src="https://jspm.dev/es-module-shims"></script>
  </head>
  <body>
    <!-- Here's a simple Three.js scene. -->
    <three-game id="game" autorender>
      <three-scene background-color="#222">
        <scene-lights></scene-lights>
        <game-board></game-board>
        <three-orbit-controls></three-orbit-controls>
      </three-scene>
    </three-game>

    <!-- Import dependencies via ESM. The future is now! -->
    <script type="module">
      import { css, html, LitElement } from "https://jspm.dev/lit-element"
      import { component, useState } from "https://jspm.dev/haunted"

      importShim("/dist/index.esm.js").then(() => {
        customElements.define(
          "scene-lights",
          component(() => {
            return html`
              <three-fog near="0" far="32" color="#111"></three-fog>
              <three-ambient-light intensity="0.2"></three-ambient-light>
              <three-directional-light
                position="10, 10, 40"
                intensity="0.8"
              ></three-directional-light>
            `
          })
        )

        const GameBoard = () => {
          const [board] = useState(new Board())
          const [selectedTile, setSelectedTile] = useState(null)

          const swapWithSelectedTile = (x, y) => {
            if (selectedTile) {
              const [sx, sy] = selectedTile
              const selectedColor = board.getTile(sx, sy)
              const otherColor = board.getTile(x, y)
              board.setTile(sx, sy, otherColor)
              board.setTile(x, y, selectedColor)

              setSelectedTile(null)
            }
          }

          const adjacentToSelectedTile = (x, y) => {
            if (selectedTile) {
              const [sx, sy] = selectedTile
              return (
                (x >= sx - 1 && x <= sx + 1 && y == sy) || (y >= sy - 1 && y <= sy + 1 && x == sx)
              )
            }
          }

          const selectTile = (x, y) => {
            /* If a tile is already selected, swap the two tiles */
            if (selectedTile && adjacentToSelectedTile(x, y)) {
              swapWithSelectedTile(x, y)
              board.clearAllMatches()
            } else {
              setSelectedTile([x, y])
            }
          }

          return html`
            <three-group position="-4, -4, 0">
              ${board.board.map((row, y) =>
                row.map((color, x) => {
                  return color
                    ? html`<game-tile
                        .onclick=${() => selectTile(x, y)}
                        color=${color}
                        y=${y}
                        x=${x}
                        ?selected=${selectedTile && x == selectedTile[0] && y == selectedTile[1]}
                      ></game-tile>`
                    : null
                })
              )}
            </three-group>
          `
        }

        customElements.define("game-board", component(GameBoard))

        const GameTile = ({ x, y, selected, color }) => {
          const [hover, setHover] = useState(false)

          const onTick = (dt, { object, game }) => {
            object.rotation.x = object.rotation.y += (hover ? 1.5 : 0.5) * dt
            game.requestFrame()
          }

          return html`
            <three-group position.x=${x} position.y=${y} scale=${selected ? 1.3 : 1}>
              <three-mesh
                scale="0.4"
                .ontick=${onTick}
                .onpointerenter=${(e) => setHover(true)}
                .onpointerleave=${(e) => setHover(false)}
              >
                <three-dodecahedron-buffer-geometry></three-dodecahedron-buffer-geometry>
                <three-mesh-standard-material
                  color=${color}
                  emissive=${hover ? color : ""}
                  emissive-intensity=${hover ? 0.9 : 0}
                ></three-mesh-standard-material>
              </three-mesh>
            </three-group>
          `
        }

        GameTile.observedAttributes = ["x", "y", "color", "selected"]

        customElements.define("game-tile", component(GameTile))

        class Board {
          constructor() {
            const makeRow = () => {
              const row = []
              for (let x = 0; x < 8; x++) row.push(pickRandomTile())
              return row
            }

            const makeBoard = () => {
              const rows = []
              for (let y = 0; y < 8; y++) rows.push(makeRow())
              return rows
            }

            const tiles = ["#2f2", "white", "#22f", "#f22"]

            const pickRandomTile = () => tiles[Math.floor(Math.random() * tiles.length)]

            this.board = makeBoard()
          }

          getTile(x, y) {
            return this.board[y][x]
          }

          setTile(x, y, color) {
            this.board[y][x] = color
          }

          removeTile(x, y) {
            this.setTile(x, y, null)
          }

          findMatchAt(x, y) {
            const color = this.getTile(x, y)

            if (color) {
              {
                /* find horizontal match */
                let match = []
                for (let sx = x; sx < 8; sx++) {
                  if (this.getTile(sx, y) == color) match.push([sx, y])
                  else break
                }
                if (match.length >= 3) return match
              }

              {
                /* find vertical match */
                let match = []
                for (let sy = y; sy < 8; sy++) {
                  if (this.getTile(x, sy) == color) match.push([x, sy])
                  else break
                }
                if (match.length >= 3) return match
              }
            }
          }

          findMatch() {
            for (let y = 0; y < 8; y++) {
              for (let x = 0; x < 8; x++) {
                const match = this.findMatchAt(x, y)
                if (match) return match
              }
            }
          }

          clearMatch(match) {
            for (const position of match) {
              this.removeTile(position[0], position[1])
            }
          }

          clearAllMatches() {
            let match
            while ((match = this.findMatch())) {
              console.log("clearing match:", match)
              this.clearMatch(match)
            }
          }
        }
      })
    </script>

    <script type="importmap-shim">
      {
        "imports": {
          "eventemitter3": "https://jspm.dev/eventemitter3",
          "three": "https://jspm.dev/three",
          "three/": "https://jspm.dev/three/"
        }
      }
    </script>
  </body>
</html>
